#!/bin/bash

####### USER-SETTABLE STRING CONSTANTS #######

## The path to the notary client
test -z "${NOTARY_CLIENT}" && NOTARY_CLIENT=/usr/bin/notary

## The number of times we should retry Notary commands
test -z "${RETRIES}" && RETRIES=5

## X509 cert
##### Must be present and identical on all machines
##### Must form a valid keypair with ${TRUST_PINNING_KEY}
test -z "${TRUST_PINNING_CERT}" && TRUST_PINNING_CERT="${HOME}/docker_certs/trust_pinning.crt"

## X509 cert
##### Must be present and identical on all pushing machines
##### Must form a valid keypair with ${DELEGATION_KEY}
test -z "${DELEGATION_CERT}" && DELEGATION_CERT="${HOME}/docker_certs/delegation.crt"

## Private key
##### Must be present and identical on all pushing machines
##### Must form a valid keypair with ${TRUST_PINNING_CERT}
test -z "${TRUST_PINNING_KEY}" && TRUST_PINNING_KEY="${HOME}/docker_keys/trust_pinning.key"

## Private key
##### Must be present and identical on all pushing machines
##### Must form a valid keypair with ${DELEGATION_CERT}
test -z "${DELEGATION_KEY}" && DELEGATION_KEY="${HOME}/docker_keys/delegation.key"

## The length of validity of certs generated by notary-utils
test -z "${CERT_DAYS}" && CERT_DAYS=3650

## The length of the private key generated by notary-utils
test -z "${ROOT_KEY_LENGTH}" && ROOT_KEY_LENGTH=2048


####### INTERNAL STRING CONSTANTS #######

export NOTARY_ROOT_PASSPHRASE=notary_root_passphrase
export NOTARY_TARGETS_PASSPHRASE=notary_targets_passphrase
export NOTARY_DELEGATION_PASSPHRASE=notary_delegation_passphrase
DOCKER_TRUST_DIR="${HOME}/.docker/trust" ## hardcoded in Docker
NOTARY_CONFIG_FILE="${HOME}/.notary/config.json" ## hardcoded in Notary

## This should actually perform an alert somehow
fail() {
    echo "$@"
    exit 1
}

warn() {
    echo "WARNING: $@"
}

debug() {
   if test -n "${DEBUG}"; then
        >&2 echo "$@"
   fi
}

check_notary_client() {
  if test -z "$NOTARY_CLIENT"; then
    fail "NOTARY_CLIENT environment variable must be defined"
  fi

  which ${NOTARY_CLIENT} >/dev/null 2>/dev/null || fail "Command $NOTARY_CLIENT not found"
}

check_notary_url() {
  ## NOTARY_URL must be set to the URL of the notary server
  if test -z "$NOTARY_URL"; then
      fail "NOTARY_URL must be set"
  fi
}

## Call this method before anything that requires Notary
perform_notary_checks() {
  check_notary_client
  check_notary_url
}

##
## Configure Notary so that it will accept values from the server only when
##  they have certs signed by $TRUST_PINNING_KEY
##
## This could just be done once per host for all time, 
##  but I prefer to check it every time
##
setup_trust_pinning() {
    ## For the format, see https://github.com/docker/notary/blob/master/docs/reference/client-config.md
    local expected_contents="{ \"trust_pinning\": { \"disable_tofu\": \"true\",\"ca\": { \"\":\"${TRUST_PINNING_CERT}\" } } }" 
    if test -f ${NOTARY_CONFIG_FILE}; then
        local actual_contents="$(cat ${NOTARY_CONFIG_FILE})"
        test "$expected_contents" == "$actual_contents" || \
            fail "$notary_config_file found but had unexpected contents: '$actual_contents': expected '$expected_contents'"
    else
        mkdir -p $(dirname ${NOTARY_CONFIG_FILE}) ||
            fail "Unable to create directory $(dirname ${NOTARY_CONFIG_FILE})"
        echo "$expected_contents" > ${NOTARY_CONFIG_FILE} || \
            fail "Unable to write to ${NOTARY_CONFIG_FILE}"
    fi
}

## Returns 0 if a call to the Docker CLI from the current
##  context requires sudo
## Returns 1 otherwise
docker_requires_sudo() {
  test -e /var/run/docker.sock && ! touch /var/run/docker.sock 2>/dev/null
}

## Invokes the Docker CLI with the given parameters, applying sudo if
## necessary.
## 
## Params containing whitespace need to be quoted AND have the whitespace escaped
##  e.g. invoke_docker images --format "{{.Repository}}\ {{.Tag}}"
##
## Returns the return value of the underlying Docker CLI call.
invoke_docker() {
    if docker_requires_sudo; then
        ## preserve environment variables
        sudo -E bash -c "docker $*"
    else
        bash -c "docker $*"
    fi
}

### Examine the passed-in parameters to see
### whether they contains strings characteristic of 
### a failure to connect by the Notary client
notary_output_shows_failure_to_connect() {
    echo "$@" | grep -qP "client is offline|unable to reach trust server"
}


### Call notary up to $RETRIES times
### retrying every time the notary client fails to connect
invoke_notary_with_retry() {
    local output
    local exitval
    for ((i=1; i<=RETRIES; i++)); do
        debug "NOTARY CLIENT ATTEMPT ${i} OF ${RETRIES}"
        output="$(invoke_notary "$@")"
        exitval=$?
        if test "$exitval" == 0 ||
           ! notary_output_shows_failure_to_connect "$output"; then
            break
        fi
    done
    echo "$output"
    return $exitval
}

##
## Invoke a remote Notary server at $NOTARY_URL, using values from the local
##
invoke_notary() {
    perform_notary_checks
    mkdir -p ${DOCKER_TRUST_DIR} || fail "Could not create ${DOCKER_TRUST_DIR}"
    local exitval output
    debug "RUNNING: '${NOTARY_CLIENT} ${NOTARY_ARGS} -s ${NOTARY_URL} -d ${DOCKER_TRUST_DIR} $@'"
    output="$(${NOTARY_CLIENT} ${NOTARY_ARGS} -s ${NOTARY_URL} -d ${DOCKER_TRUST_DIR} "$@")"
    exitval=$?
    debug "OUTPUT: '${output}'"
    debug "EXIT STATUS: $exitval"
    debug ""
    echo "${output}"
    return $exitval
}

## Return values to the query_notary_repo function (see below)
ALREADY_INITIALIZED=0
DOES_NOT_EXIST=1
UNTRUSTED=2
ERROR=3

##
## Checks whether the specified repository has 
##  already been initialized on the remote Notary server
##  at $NOTARY_URL
##
## Param: $1 the name of the repository
##
## Returns:
##          $ALREADY_INITIALIZED if the repository has already been initialized
##          $DOES_NOT_EXIST      if the repository is not found
##          $UNTRUSTED           if the repository is found, but the root cannot be validated
##          $ERROR               if an error is encountered
##
query_notary_repo() {
    perform_notary_checks
    local remote_repo="$1"
    local output
    if output="$(invoke_notary_with_retry list "$remote_repo")"; then
        return $ALREADY_INITIALIZED
    elif echo "$output" | grep -q "does not have trust data for $remote_repo"; then  
        return $DOES_NOT_EXIST
    elif echo "$output" | grep -q "could not validate the path to a trusted root"; then
        return $UNTRUSTED
    else
        echo "$output"
        return $ERROR
    fi
}

#### Generates a new certificate signing request (CSR) using 
#### for the certificate that will be used to initialize
#### the new repo in Notary

generate_new_csr() {
    #### Note: we do not use openssl to generate the CSR
    #### because it refuses to handle a CN of length >64 characters
    local tmpdir=$1
    local remote_repo=$2
    local new_key_unencrypted=$3
    local new_csr=$4

    local new_crt_cfg=${tmpdir}/new_crt.cfg

    local cert_issuer="$(openssl x509 -in ${TRUST_PINNING_CERT} -issuer -noout)" \
      || fail "Unable to determine certificate issuer data for ${TRUST_PINNING_CERT}"
    local cert_country="$(echo "${cert_issuer}" | grep -oP "/C=[^/]+" | grep -oP "[^=]+$")"
    local cert_state="$(echo "${cert_issuer}" | grep -oP "/ST=[^/]+" | grep -oP "[^=]+$")"
    local cert_locality="$(echo "${cert_issuer}" | grep -oP "/L=[^/]+" | grep -oP "[^=]+$")"
    local cert_organization="$(echo "${cert_issuer}" | grep -oP "/O=[^/]+" | grep -oP "[^=]+$")"

    (
        echo "country      = \"${cert_country}\""
        echo "state        = \"${cert_state}\""
        echo "locality     = \"${cert_locality}\""
        echo "organization = \"${cert_organization}\""
        echo "cn           = \"${remote_repo}\""
    ) > $new_crt_cfg || \
        fail "Could not create configuration file for request generation"

   debug "Contents of $new_crt_cfg = '$(cat $new_crt_cfg)'"

    certtool --generate-request --load-privkey $new_key_unencrypted --template $new_crt_cfg --outfile ${new_csr} || \
        fail "Could not generate request"
}

## Generate a keypair to initialize a new repo
##
## The private key is an RSA key of length $ROOT_KEY_LENGTH
## encrypted using AES-128 with passphrase $NOTARY_DELEGATION_PASSPHRASE
##
## The public key is contained in an X509 cert whose common name
## is the remote repo.  The X509 cert is signed by $TRUST_PINNING_KEY
##
## Parameters:
## $1 A directory in which to create the key and cert
## $2 The remote repo
## $3 The filename in which to place the new private key
## $4 The filename in which to place the new cert
##
generate_new_key_and_cert() {
    local tmpdir=$1
    local remote_repo=$2
    local new_key_filename=$3
    local new_crt_filename=$4

    local new_key=$tmpdir/$new_key_filename
    local new_crt=$tmpdir/$new_crt_filename
    local new_key_unencrypted=$tmpdir/${new_key_filename}.unencrypted
    local new_csr=$tmpdir/new.csr

    ## First, generate the unencrypted root key required by certtool
    openssl genrsa $ROOT_KEY_LENGTH > $new_key_unencrypted || \
        fail "Could not generate new key at $new_key_unencrypted"

    ### Encrypt the key with AES-128 (Notary requires the key to be encrypted for import)
    openssl rsa -aes128 -in $new_key_unencrypted -out $new_key -passout pass:$NOTARY_DELEGATION_PASSPHRASE || \
        fail "Could not encrypt key $new_key_unencrypted"

    ### Generate the signing request (CSR) and put it in ${new_csr}
    generate_new_csr "${tmpdir}" "${remote_repo}" "${new_key_unencrypted}" "${new_csr}"

    ### Generate the certificate and put it in ${new_crt}
    openssl x509 -req -sha256 -in "${new_csr}" -out "${new_crt}" -days $CERT_DAYS \
        -CAkey ${TRUST_PINNING_KEY} -CA ${TRUST_PINNING_CERT} -CAcreateserial || \
        fail "Could not generate new cert at $new_crt"
}

##
## Initializes the specified repository on the
##  remote Notary server at $NOTARY_URL.  
## Generates a key / cert pair, with the
##  cert signed by $TRUST_PINNING_KEY, and
##  uses that generated key and cert as 
##  the root of trust for the repository.
## Also adds a delegation to $DELEGATION_KEY
##  so that other authorized machines will
##  be able to push to this repository in 
##  future.
##
## Param: $1 the name of the repository
##
## Returns: 0 if all operations succeeded; nonzero otherwise
init_notary_repo() {
    perform_notary_checks
    local remote_repo="$1"

    local tmpdir=$(mktemp /tmp/XXXXXXXXXX) || fail "Could not get temporary directory"
    rm -fr $tmpdir
    mkdir -p $tmpdir || fail "Could not create temporary directory $tmpdir"

    local new_key_filename=new.key
    local new_crt_filename=new.crt

    generate_new_key_and_cert $tmpdir $remote_repo $new_key_filename $new_crt_filename

    ## Use the new cert / key to initialize notary
    invoke_notary init --rootkey $tmpdir/$new_key_filename --rootcert $tmpdir/$new_crt_filename $remote_repo || \
        fail "Could not initialize new Notary repo at $remote_repo"

    ## Cleanup
    rm -fr $tmpdir >/dev/null

    ## Add a delegation to $DELEGATION_CERT
    ##
    ## This allows any Notary client that has imported $DELEGATION_KEY
    ## to push changes to this Notary repo.
    ##
    ## This is crucial to allow us to generate Docker images on multiple
    ## machines and have them all push to the same repos.
    ##
    ## See: https://github.com/docker/notary/blob/master/docs/advanced_usage.md
    ##      https://docs.docker.com/engine/security/trust/trust_delegation/
    invoke_notary key rotate ${remote_repo} snapshot -r || \
        warn "Could not rotate key in new Notary repo at $remote_repo." && \
        warn "This may not be required on some version of Notary.  Will continue."

    invoke_notary delegation add $remote_repo targets/releases $DELEGATION_CERT --all-paths || \
        fail "Could not add delegation cert $DELEGATION_CERT to new Notary repo at $remote_repo"

    ## ignore failure on publish, because there could be a race condition where two
    ##  clients both try to push to the same new repo simultanrously
    ##  If this failure happens, we just ignore and retry
    invoke_notary publish $remote_repo
}

## Subsidiary push function
##  * tags the local image, 
##  * sets the environment variables for Content Trust
##  * invokes docker push
##
##  Parameters:
##    $1 a way of referring to the local image to be pushed
##    $2 the remote repo, including the host (and port, if required)
##    $3 the remote tag
perform_docker_push() {
    perform_notary_checks
    local local_image="$1"
    local remote_repo="$2"
    local remote_tag="$3"

    invoke_docker tag $local_image ${remote_repo}:$remote_tag || \
        fail "Docker tag $local_image ${remote_repo}:$remote_tag failed"

    ## Import the delegation key so that this client has permission
    ##  to push to the remote Notary repo
    ## (this could just be done once per host for all time, 
    ##  but I prefer to do it every time -- it will be a no-op if already
    ##  imported).
    invoke_notary key import ${DELEGATION_KEY} --role targets/user

    ## These environment variables are required by Docker Content trust
    export DOCKER_CONTENT_TRUST_ROOT_PASSPHRASE=${NOTARY_ROOT_PASSPHRASE}
    export DOCKER_CONTENT_TRUST_REPOSITORY_PASSPHRASE=${NOTARY_TARGETS_PASSPHRASE}
    export DOCKER_CONTENT_TRUST=1
    export DOCKER_CONTENT_TRUST_SERVER=${NOTARY_URL}
    ## this requires the -D flag because of a Docker bug
    echo $NOTARY_DELEGATION_PASSPHRASE | invoke_docker -D push ${remote_repo}:$remote_tag || \
        fail "Docker push ${remote_repo}:$remote_tag failed"
}

## Subsidiary pull function
##  * sets the environment variables for Content Trust
##  * invokes docker pull
##
##  Parameters:
##    $1 the remote repo, including the host (and port, if required)
##    $2 the remote tag
perform_docker_pull() {
    ## We have to use Notary until the Squid proxy starts supporting
    ## the ciphers supported by Docker commandline
    perform_docker_pull_using_notary "$@"
}

## Looks up the digest of $remote_repo:$remote_tag in Notary
lookup_digest_in_notary() {
    perform_notary_checks
    local remote_repo="$1"
    local remote_tag="$2"

    local notary_output exitval
    notary_output="$(invoke_notary_with_retry lookup ${remote_repo} ${remote_tag})"
    exitval=$?
    if test "$exitval" == 0; then
        echo "${notary_output}" | awk '{print $2}' | head -n 1
    else
        echo "${notary_output}"
        return $exitval
    fi
}

### Calls docker pull up to $RETRIES times
### retrying every time the pull fails
invoke_docker_pull_with_retry() {
    local output
    local exitval
    for ((i=1; i<=RETRIES; i++)); do
        debug "DOCKER PULL ATTEMPT ${i} OF ${RETRIES}"
        output="$(invoke_docker pull "$@")"
        exitval=$?
        if test "$exitval" == 0; then
            break
        fi
    done
    echo "$output"
    return $exitval
}

## Subsidiary pull function
##  * sets the environment variables for Content Trust
##  * invokes docker pull
##
##  Parameters:
##    $1 the remote repo, including the host (and port, if required)
##    $2 the remote tag
##
##  Alternative implementation to bypass proxy issue in live
perform_docker_pull_using_notary() {
    perform_notary_checks
    local remote_repo="$1"
    local remote_tag="$2"

    local digest="$(lookup_digest_in_notary ${remote_repo} ${remote_tag})" || \
        fail "Unable to lookup digest for ${remote_repo}:${remote_tag} in Notary: output was '${digest}'"

    test -n "$digest" || \
        fail "Digest for ${remote_repo}:${remote_tag} in Notary was empty"

    invoke_docker_pull_with_retry "${remote_repo}@${digest}" || \
        fail "Docker pull ${remote_repo}@${digest} failed"

    invoke_docker tag ${remote_repo}@${digest} ${remote_repo}:${remote_tag} || \
        fail "Docker tag ${remote_repo}@${digest} ${remote_repo}:${remote_tag} failed"
}

## Main push function.
## 
## 1. Set up trust pinning, so that Notary values read from the remote
##     server will be accepted only if authenticated by the private key
## 2. Has anyone ever pushed to this Notary repo before?
## 3a. If no, then initialize and publish a new remote Notary repo, 
##      with trust delegated to the delegation key.  Then continue to step 4.
## 3b. If yes, then continue directly to step 4.
## 4. Perform a Docker Content Trust push
##
##  Parameters:
##    $1 a way of referring to the local image to be pushed
##    $2 the remote repo, including the host (and port, if required)
##    $3 the remote tag
push() {
    local local_image="$1"
    local remote_repo="$2"
    local remote_tag="$3"

    setup_trust_pinning

    MAX_ATTEMPTS=3

    for ((i=0; ;i++)); do

        output=$(query_notary_repo "$remote_repo")
        local exit_val=$?

        case $exit_val in

            $ALREADY_INITIALIZED)
                echo "Notary repo already initialized: proceeding with a normal push"
                perform_docker_push "$local_image" "$remote_repo" "$remote_tag"
                return $?
                ;;

            ## If this is a brand-new repository, we create it then loop back
            ##  to perform the Docker push.
            $DOES_NOT_EXIST)
                test $i -ge $MAX_ATTEMPTS && break
                echo "Initializing Notary repo for $remote_repo"
                init_notary_repo "$remote_repo"
                ;;

            $UNTRUSTED)
                fail "Found a pre-existing Notary repo for $remote_repo, but it is untrusted.  This may indicate a security violation."
                ;;

            $ERROR)
                fail "Unexpected error on querying Notary server for $remote_repo: output='$output'."
                ;;

            *)
                fail "Unexpected return value: $exit_val"
                ;;
        esac
    done

    fail "After $MAX_ATTEMPTS attempts, was still unable to initialize a Notary repository for $remote_repo: output was '$output'"
}

## Main pull function.
## 
## 1. Set up trust pinning, so that Notary values read from the remote
##     server will be accepted only if authenticated by the private key
## 2. Has anyone ever pushed to this Notary repo before?
## 3a. If no, then fail with an error message
## 3b. If yes, then continue directly to step 4.
## 4. Perform a Docker Content Trust pull
##
##  Parameters:
##    $1 the remote repo, including the host (and port, if required)
##    $2 the remote tag
pull() {
    local remote_repo="$1"
    local remote_tag="$2"

    setup_trust_pinning

    perform_docker_pull_using_notary "$remote_repo" "$remote_tag"
}
